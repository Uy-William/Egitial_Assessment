(function (global, factory) {
typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('react'), require('events')) :
typeof define === 'function' && define.amd ? define(['exports', 'react', 'events'], factory) :
(global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.GraphQLHooks = {}, global.React, global.EventEmitter));
}(this, (function (exports, React, EventEmitter) { 'use strict';

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var React__default = /*#__PURE__*/_interopDefaultLegacy(React);
var EventEmitter__default = /*#__PURE__*/_interopDefaultLegacy(EventEmitter);

function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread2(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {
      _defineProperty(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }

  return target;
}

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;

  _setPrototypeOf(subClass, superClass);
}

function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}

function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}

function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];

  return arr2;
}

function _createForOfIteratorHelperLoose(o, allowArrayLike) {
  var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
  if (it) return (it = it.call(o)).next.bind(it);

  if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
    if (it) o = it;
    var i = 0;
    return function () {
      if (i >= o.length) return {
        done: true
      };
      return {
        done: false,
        value: o[i++]
      };
    };
  }

  throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

var ClientContext = React__default['default'].createContext();
ClientContext.displayName = 'ClientContext';

/**
 * Used to mark a
 * [React Native `File` substitute]{@link ReactNativeFileSubstitute}
 * in an object tree for [`extractFiles`]{@link extractFiles}. Itâ€™s too risky to
 * assume all objects with `uri`, `type` and `name` properties are files to
 * extract.
 * @kind class
 * @name ReactNativeFile
 * @param {ReactNativeFileSubstitute} file A [React Native](https://reactnative.dev) [`File`](https://developer.mozilla.org/en-US/docs/Web/API/File) substitute.
 * @example <caption>Ways to `import`.</caption>
 * ```js
 * import { ReactNativeFile } from 'extract-files';
 * ```
 *
 * ```js
 * import ReactNativeFile from 'extract-files/public/ReactNativeFile.js';
 * ```
 * @example <caption>Ways to `require`.</caption>
 * ```js
 * const { ReactNativeFile } = require('extract-files');
 * ```
 *
 * ```js
 * const ReactNativeFile = require('extract-files/public/ReactNativeFile.js');
 * ```
 * @example <caption>An extractable file in [React Native](https://reactnative.dev).</caption>
 * ```js
 * const file = new ReactNativeFile({
 *   uri: uriFromCameraRoll,
 *   name: 'a.jpg',
 *   type: 'image/jpeg',
 * });
 * ```
 */

var ReactNativeFile_1 = class ReactNativeFile {
  constructor({
    uri,
    name,
    type
  }) {
    this.uri = uri;
    this.name = name;
    this.type = type;
  }

};

/**
 * Checks if a value is an [extractable file]{@link ExtractableFile}.
 * @kind function
 * @name isExtractableFile
 * @type {ExtractableFileMatcher}
 * @param {*} value Value to check.
 * @returns {boolean} Is the value an [extractable file]{@link ExtractableFile}.
 * @example <caption>Ways to `import`.</caption>
 * ```js
 * import { isExtractableFile } from 'extract-files';
 * ```
 *
 * ```js
 * import isExtractableFile from 'extract-files/public/isExtractableFile.js';
 * ```
 * @example <caption>Ways to `require`.</caption>
 * ```js
 * const { isExtractableFile } = require('extract-files');
 * ```
 *
 * ```js
 * const isExtractableFile = require('extract-files/public/isExtractableFile.js');
 * ```
 */


var isExtractableFile = function isExtractableFile(value) {
  return typeof File !== 'undefined' && value instanceof File || typeof Blob !== 'undefined' && value instanceof Blob || value instanceof ReactNativeFile_1;
};

/**
 * Clones a value, recursively extracting
 * [`File`](https://developer.mozilla.org/en-US/docs/Web/API/File),
 * [`Blob`](https://developer.mozilla.org/en-US/docs/Web/API/Blob) and
 * [`ReactNativeFile`]{@link ReactNativeFile} instances with their
 * [object paths]{@link ObjectPath}, replacing them with `null`.
 * [`FileList`](https://developer.mozilla.org/en-US/docs/Web/API/Filelist) instances
 * are treated as [`File`](https://developer.mozilla.org/en-US/docs/Web/API/File)
 * instance arrays.
 * @kind function
 * @name extractFiles
 * @param {*} value Value (typically an object tree) to extract files from.
 * @param {ObjectPath} [path=''] Prefix for object paths for extracted files.
 * @param {ExtractableFileMatcher} [isExtractableFile=isExtractableFile] The function used to identify extractable files.
 * @returns {ExtractFilesResult} Result.
 * @example <caption>Ways to `import`.</caption>
 * ```js
 * import { extractFiles } from 'extract-files';
 * ```
 *
 * ```js
 * import extractFiles from 'extract-files/public/extractFiles.js';
 * ```
 * @example <caption>Ways to `require`.</caption>
 * ```js
 * const { extractFiles } = require('extract-files');
 * ```
 *
 * ```js
 * const extractFiles = require('extract-files/public/extractFiles.js');
 * ```
 * @example <caption>Extract files from an object.</caption>
 * For the following:
 *
 * ```js
 * const file1 = new File(['1'], '1.txt', { type: 'text/plain' });
 * const file2 = new File(['2'], '2.txt', { type: 'text/plain' });
 * const value = {
 *   a: file1,
 *   b: [file1, file2],
 * };
 *
 * const { clone, files } = extractFiles(value, 'prefix');
 * ```
 *
 * `value` remains the same.
 *
 * `clone` is:
 *
 * ```json
 * {
 *   "a": null,
 *   "b": [null, null]
 * }
 * ```
 *
 * `files` is a [`Map`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map) instance containing:
 *
 * | Key     | Value                        |
 * | :------ | :--------------------------- |
 * | `file1` | `['prefix.a', 'prefix.b.0']` |
 * | `file2` | `['prefix.b.1']`             |
 */


var extractFiles = function extractFiles(value, path = '', isExtractableFile$1 = isExtractableFile) {
  // Map of extracted files and their object paths within the input value.
  const files = new Map(); // Map of arrays and objects recursed within the input value and their clones,
  // for reusing clones of values that are referenced multiple times within the
  // input value.

  const clones = new Map();
  /**
   * Recursively clones the value, extracting files.
   * @kind function
   * @name extractFiles~recurse
   * @param {*} value Value to extract files from.
   * @param {ObjectPath} path Prefix for object paths for extracted files.
   * @param {Set} recursed Recursed arrays and objects for avoiding infinite recursion of circular references within the input value.
   * @returns {*} Clone of the value with files replaced with `null`.
   * @ignore
   */

  function recurse(value, path, recursed) {
    let clone = value;

    if (isExtractableFile$1(value)) {
      clone = null;
      const filePaths = files.get(value);
      filePaths ? filePaths.push(path) : files.set(value, [path]);
    } else {
      const isList = Array.isArray(value) || typeof FileList !== 'undefined' && value instanceof FileList;
      const isObject = value && value.constructor === Object;

      if (isList || isObject) {
        const hasClone = clones.has(value);
        if (hasClone) clone = clones.get(value);else {
          clone = isList ? [] : {};
          clones.set(value, clone);
        }

        if (!recursed.has(value)) {
          const pathPrefix = path ? `${path}.` : '';
          const recursedDeeper = new Set(recursed).add(value);

          if (isList) {
            let index = 0;

            for (const item of value) {
              const itemClone = recurse(item, pathPrefix + index++, recursedDeeper);
              if (!hasClone) clone.push(itemClone);
            }
          } else for (const key in value) {
            const propertyClone = recurse(value[key], pathPrefix + key, recursedDeeper);
            if (!hasClone) clone[key] = propertyClone;
          }
        }
      }
    }

    return clone;
  }

  return {
    clone: recurse(value, path, new Set()),
    files
  };
};

var canUseDOM = (function () {
  return typeof window !== 'undefined' && typeof window.document !== 'undefined' && typeof window.document.createElement !== 'undefined';
});

var isExtractableFileEnhanced = function isExtractableFileEnhanced(value) {
  return isExtractableFile(value) || // Check if stream
  // https://github.com/sindresorhus/is-stream/blob/3750505b0727f6df54324784fe369365ef78841e/index.js#L3
  value !== null && typeof value === 'object' && typeof value.pipe === 'function' || // Check if formdata-node File
  // https://github.com/octet-stream/form-data/blob/14a6708f0ae28a5ffded8b6f8156394ba1d1244e/lib/File.ts#L29
  value !== null && typeof value === 'object' && typeof value.stream === 'function';
};

/**
 * Generic Middleware function that
 * will run object through all provided functions
 *
 *
 * Minimal example:
 * const MyMiddleware = ({ operation }, next) => {
 *   operation.variables.user = 'admin'
 *   next()
 * }
 *
 * All parameters provided are written in run function JSDoc
 */
var Middleware = /*#__PURE__*/function () {
  function Middleware(fns) {
    var _this = this;

    if (fns.length === 0) {
      // Pass through
      fns.push(function (_, next) {
        return next();
      });
    }

    var _loop = function _loop() {
      var fn = _step.value;

      if (typeof fn !== 'function') {
        throw new Error('GraphQLClient Middleware: middleware has to be of type `function`');
      }

      _this.run = function (stack) {
        return function (opts, next) {
          stack(opts, function () {
            fn.apply(_this, [opts, next.bind.apply(next, [null, opts])]);
          });
        };
      }(_this.run);
    };

    for (var _iterator = _createForOfIteratorHelperLoose(fns), _step; !(_step = _iterator()).done;) {
      _loop();
    }
  }
  /**
   * Run middleware
   * @param {opts.client} GraphQLClient instance
   * @param {opts.operation} Operation object with properties such as query and variables
   * @param {opts.resolve} Used to early resolve the request
   * @param {opts.addResponseHook} Hook that accepts a function that will be run after response is fetched
   * @param {opts.reject} User to early reject the request
   * @param {function} next
   */


  var _proto = Middleware.prototype;

  _proto.run = function run(opts, next) {
    next.apply(this, opts);
  };

  return Middleware;
}();

/**
 * Pipe with support for async functions
 * @param {array} array of functions
 * @returns single function
 */
var pipeP = function pipeP(fns) {
  return function (arg) {
    return fns.reduce(function (p, f) {
      return p.then(f);
    }, Promise.resolve(arg));
  };
};

var GraphQLClient = /*#__PURE__*/function () {
  function GraphQLClient(config) {
    if (config === void 0) {
      config = {};
    }

    // validate config
    this.fullWsTransport = config.fullWsTransport;
    this.subscriptionClient = config.subscriptionClient;

    if (typeof this.subscriptionClient === 'function') {
      this.subscriptionClient = this.subscriptionClient();
    }

    this.verifyConfig(config);
    this.cache = config.cache;
    this.headers = config.headers || {};
    this.ssrMode = config.ssrMode;
    this.ssrPromises = [];
    this.url = config.url;
    this.fetch = config.fetch || typeof fetch !== 'undefined' && fetch && fetch.bind();
    this.fetchOptions = config.fetchOptions || {};
    this.FormData = config.FormData || (typeof FormData !== 'undefined' ? FormData : undefined);
    this.logErrors = config.logErrors !== undefined ? config.logErrors : true;
    this.onError = config.onError;
    this.useGETForQueries = config.useGETForQueries === true;
    this.middleware = new Middleware(config.middleware || []);
    this.mutationsEmitter = new EventEmitter__default['default']();
  }
  /** Checks that the given config has the correct required options */


  var _proto = GraphQLClient.prototype;

  _proto.verifyConfig = function verifyConfig(config) {
    if (!config.url) {
      if (this.fullWsTransport) {
        // check if there's a subscriptionClient
        if (!this.subscriptionClient) {
          throw new Error('GraphQLClient: subscriptionClient is required');
        }
      } else {
        throw new Error('GraphQLClient: config.url is required');
      }
    }

    if (config.fetch && typeof config.fetch !== 'function') {
      throw new Error('GraphQLClient: config.fetch must be a function');
    }

    if ((canUseDOM() || config.ssrMode) && !config.fetch && typeof fetch !== 'function') {
      throw new Error('GraphQLClient: fetch must be polyfilled or passed in new GraphQLClient({ fetch })');
    }

    if (config.ssrMode && !config.cache) {
      throw new Error('GraphQLClient: config.cache is required when in ssrMode');
    }
  };

  _proto.setHeader = function setHeader(key, value) {
    this.headers[key] = value;
    return this;
  };

  _proto.setHeaders = function setHeaders(headers) {
    this.headers = headers;
    return this;
  };

  _proto.removeHeader = function removeHeader(key) {
    delete this.headers[key];
    return this;
  }
  /* eslint-disable no-console */
  ;

  _proto.logErrorResult = function logErrorResult(_ref) {
    var result = _ref.result,
        operation = _ref.operation;
    console.error('GraphQL Hooks Error');
    console.groupCollapsed('---> Full Error Details');
    console.groupCollapsed('Operation:');
    console.log(operation);
    console.groupEnd();
    var error = result.error;

    if (error) {
      if (error.fetchError) {
        console.groupCollapsed('FETCH ERROR:');
        console.log(error.fetchError);
        console.groupEnd();
      }

      if (error.httpError) {
        console.groupCollapsed('HTTP ERROR:');
        console.log(error.httpError);
        console.groupEnd();
      }

      if (error.graphQLErrors && error.graphQLErrors.length > 0) {
        console.groupCollapsed('GRAPHQL ERROR:');
        error.graphQLErrors.forEach(function (err) {
          return console.log(err);
        });
        console.groupEnd();
      }
    }

    console.groupEnd();
  }
  /* eslint-enable no-console */
  ;

  _proto.generateResult = function generateResult(_ref2) {
    var fetchError = _ref2.fetchError,
        httpError = _ref2.httpError,
        graphQLErrors = _ref2.graphQLErrors,
        data = _ref2.data;
    var errorFound = !!(graphQLErrors && graphQLErrors.length > 0 || fetchError || httpError);
    return !errorFound ? {
      data: data
    } : {
      data: data,
      error: {
        fetchError: fetchError,
        httpError: httpError,
        graphQLErrors: graphQLErrors
      }
    };
  };

  _proto.getCacheKey = function getCacheKey(operation, options) {
    if (options === void 0) {
      options = {};
    }

    var fetchOptions = _objectSpread2(_objectSpread2({}, this.fetchOptions), options.fetchOptionsOverrides);

    return {
      operation: operation,
      fetchOptions: fetchOptions
    };
  };

  _proto.getCache = function getCache(cacheKey) {
    var cacheHit = this.cache ? this.cache.get(cacheKey) : null;

    if (cacheHit) {
      return cacheHit;
    }
  };

  _proto.saveCache = function saveCache(cacheKey, value) {
    if (this.cache) {
      this.cache.set(cacheKey, value);
    }
  } // Kudos to Jayden Seric (@jaydenseric) for this piece of code.
  // See original source: https://github.com/jaydenseric/graphql-react/blob/82d576b5fe6664c4a01cd928d79f33ddc3f7bbfd/src/universal/graphqlFetchOptions.mjs.
  ;

  _proto.getFetchOptions = function getFetchOptions(operation, fetchOptionsOverrides) {
    if (fetchOptionsOverrides === void 0) {
      fetchOptionsOverrides = {};
    }

    var fetchOptions = _objectSpread2(_objectSpread2({
      method: 'POST',
      headers: _objectSpread2({}, this.headers)
    }, this.fetchOptions), fetchOptionsOverrides);

    if (fetchOptions.method === 'GET') {
      return fetchOptions;
    }

    var _extractFiles = extractFiles(operation, '', isExtractableFileEnhanced),
        clone = _extractFiles.clone,
        files = _extractFiles.files;

    var operationJSON = JSON.stringify(clone);

    if (files.size) {
      // See the GraphQL multipart request spec:
      // https://github.com/jaydenseric/graphql-multipart-request-spec
      if (!this.FormData) {
        throw new Error('GraphQLClient: FormData must be polyfilled or passed in new GraphQLClient({ FormData })');
      }

      var form = new this.FormData();
      form.append('operations', operationJSON);
      var map = {};
      var i = 0;
      files.forEach(function (paths) {
        map[++i] = paths;
      });
      form.append('map', JSON.stringify(map));
      i = 0;
      files.forEach(function (paths, file) {
        form.append("" + ++i, file, file.name);
      });
      fetchOptions.body = form;
    } else {
      fetchOptions.headers['Content-Type'] = 'application/json';
      fetchOptions.body = operationJSON;
    }

    return fetchOptions;
  };

  _proto.request = function request(operation, options) {
    var _this = this;

    if (options === void 0) {
      options = {};
    }

    var responseHandlers = [];

    var addResponseHook = function addResponseHook(handler) {
      return responseHandlers.push(handler);
    };

    return new Promise(function (resolve, reject) {
      return _this.middleware.run({
        operation: operation,
        client: _this,
        addResponseHook: addResponseHook,
        resolve: resolve,
        reject: reject
      }, function (_ref3) {
        var updatedOperation = _ref3.operation;

        var transformResponse = function transformResponse(res) {
          if (responseHandlers.length > 0) {
            // Pipe for promises
            return pipeP(responseHandlers)(res);
          }

          return res;
        };

        if (_this.fullWsTransport) {
          return _this.requestViaWS(updatedOperation).then(transformResponse).then(resolve).catch(reject);
        }

        if (_this.url) {
          return _this.requestViaHttp(updatedOperation, options).then(transformResponse).then(resolve).catch(reject);
        }

        reject(new Error('GraphQLClient: config.url is required'));
      });
    });
  };

  _proto.requestViaHttp = function requestViaHttp(operation, options) {
    var _this2 = this;

    var url = this.url;
    var fetchOptions = this.getFetchOptions(operation, options.fetchOptionsOverrides);

    if (fetchOptions.method === 'GET') {
      var paramsQueryString = Object.entries(operation).filter(function (_ref4) {
        var k = _ref4[0],
            v = _ref4[1];
        return options.hashOnly ? k === 'variables' : !!v;
      }).map(function (_ref5) {
        var k = _ref5[0],
            v = _ref5[1];

        if (k === 'variables') {
          v = JSON.stringify(v);
        }

        return k + "=" + encodeURIComponent(v);
      }).join('&');
      url = url + '?' + paramsQueryString;

      if (operation.hash) {
        var extensions = encodeURIComponent(JSON.stringify({
          persistedQuery: {
            version: 1,
            sha256Hash: operation.hash
          }
        }));
        url += "&extensions=" + extensions;
      }
    }

    return this.fetch(url, fetchOptions).then(function (response) {
      if (!response.ok) {
        return response.text().then(function (body) {
          var status = response.status,
              statusText = response.statusText;
          return _this2.generateResult({
            httpError: {
              status: status,
              statusText: statusText,
              body: body
            }
          });
        });
      } else {
        return response.json().then(function (_ref6) {
          var errors = _ref6.errors,
              data = _ref6.data;
          return _this2.generateResult({
            graphQLErrors: errors,
            data: // enrich data with responseReducer if defined
            typeof options.responseReducer === 'function' && options.responseReducer(data, response) || data
          });
        });
      }
    }).catch(function (error) {
      return _this2.generateResult({
        fetchError: error
      });
    }).then(function (result) {
      if (result.error) {
        if (_this2.logErrors) {
          _this2.logErrorResult({
            result: result,
            operation: operation
          });
        }

        if (_this2.onError) {
          _this2.onError({
            result: result,
            operation: operation
          });
        }
      }

      return result;
    });
  };

  _proto.requestViaWS = function requestViaWS(operationPayload) {
    var _this3 = this;

    return new Promise(function (resolve, reject) {
      var data;

      try {
        var observable = _this3.createSubscription(operationPayload);

        var subscription = observable.subscribe({
          next: function next(result) {
            data = result;
          },
          error: reject,
          complete: function complete() {
            subscription.unsubscribe();
            resolve(data);
          }
        });
      } catch (e) {
        reject(e);
      }
    });
  };

  _proto.createSubscription = function createSubscription(operationPayload) {
    var _this4 = this;

    if (!this.subscriptionClient) {
      throw new Error('No SubscriptionClient! Please set in the constructor.');
    }

    if (typeof this.subscriptionClient.subscribe === 'function') {
      // graphql-ws
      return {
        subscribe: function subscribe(sink) {
          return {
            unsubscribe: _this4.subscriptionClient.subscribe(operationPayload, sink)
          };
        }
      };
    } else {
      // subscriptions-transport-ws
      return this.subscriptionClient.request(operationPayload);
    }
  };

  return GraphQLClient;
}();

/** Used to easily mock a query returning an error when using the `LocalGraphQLClient` */
var LocalGraphQLError = function LocalGraphQLError(error) {
  this.fetchError = error.fetchError;
  this.httpError = error.httpError;
  this.graphQLErrors = error.graphQLErrors;
};

/** Local version of the GraphQLClient which only returns specified queries
 * Meant to be used as a way to easily mock and test queries during development. This client never contacts any actual server.
 * Queries are given in the form of an object of functions.
 * Example:
 ```
    const localQueries = {
      [allPostsQuery]: () => ({
        allPosts: [
          {
            id: 1,
            title: 'Test',
            url: 'https://example.com'
          }
        ]
      }),
      [createPostMutation]: () => ({ createPost: { id: 1 } }),
    }
    const client = new LocalGraphQLClient({ localQueries })
  ```
 */

var LocalGraphQLClient = /*#__PURE__*/function (_GraphQLClient) {
  _inheritsLoose(LocalGraphQLClient, _GraphQLClient);

  function LocalGraphQLClient(config) {
    var _this;

    if (config === void 0) {
      config = {};
    }

    _this = _GraphQLClient.call(this, config) || this;
    _this.localQueries = config.localQueries;
    _this.requestDelayMs = config.requestDelayMs || 0;

    if (!_this.localQueries) {
      throw new Error('LocalGraphQLClient: `localQueries` object required in the constructor options');
    }

    return _this;
  }

  var _proto = LocalGraphQLClient.prototype;

  _proto.verifyConfig = function verifyConfig() {// Skips all config verification from the parent class because we're mocking the client
  };

  _proto.request = function request(operation) {
    var _this2 = this;

    if (!this.localQueries[operation.query]) {
      throw new Error("LocalGraphQLClient: no query match for: " + operation.query);
    }

    return timeoutPromise(this.requestDelayMs).then(function () {
      return Promise.resolve(_this2.localQueries[operation.query](operation.variables, operation.operationName));
    }).then(function (result) {
      if (result instanceof LocalGraphQLError) {
        return {
          error: result
        };
      }

      return {
        data: result
      };
    });
  };

  return LocalGraphQLClient;
}(GraphQLClient);

function timeoutPromise(delayInMs) {
  return new Promise(function (resolve) {
    setTimeout(resolve, delayInMs);
  });
}

var has = Object.prototype.hasOwnProperty;

function find(iter, tar, key) {
  for (key of iter.keys()) {
    if (dequal(key, tar)) return key;
  }
}

function dequal(foo, bar) {
  var ctor, len, tmp;
  if (foo === bar) return true;

  if (foo && bar && (ctor = foo.constructor) === bar.constructor) {
    if (ctor === Date) return foo.getTime() === bar.getTime();
    if (ctor === RegExp) return foo.toString() === bar.toString();

    if (ctor === Array) {
      if ((len = foo.length) === bar.length) {
        while (len-- && dequal(foo[len], bar[len]));
      }

      return len === -1;
    }

    if (ctor === Set) {
      if (foo.size !== bar.size) {
        return false;
      }

      for (len of foo) {
        tmp = len;

        if (tmp && typeof tmp === 'object') {
          tmp = find(bar, tmp);
          if (!tmp) return false;
        }

        if (!bar.has(tmp)) return false;
      }

      return true;
    }

    if (ctor === Map) {
      if (foo.size !== bar.size) {
        return false;
      }

      for (len of foo) {
        tmp = len[0];

        if (tmp && typeof tmp === 'object') {
          tmp = find(bar, tmp);
          if (!tmp) return false;
        }

        if (!dequal(len[1], bar.get(tmp))) {
          return false;
        }
      }

      return true;
    }

    if (ctor === ArrayBuffer) {
      foo = new Uint8Array(foo);
      bar = new Uint8Array(bar);
    } else if (ctor === DataView) {
      if ((len = foo.byteLength) === bar.byteLength) {
        while (len-- && foo.getInt8(len) === bar.getInt8(len));
      }

      return len === -1;
    }

    if (ArrayBuffer.isView(foo)) {
      if ((len = foo.byteLength) === bar.byteLength) {
        while (len-- && foo[len] === bar[len]);
      }

      return len === -1;
    }

    if (!ctor || typeof foo === 'object') {
      len = 0;

      for (ctor in foo) {
        if (has.call(foo, ctor) && ++len && !has.call(bar, ctor)) return false;
        if (!(ctor in bar) || !dequal(foo[ctor], bar[ctor])) return false;
      }

      return Object.keys(bar).length === len;
    }
  }

  return foo !== foo && bar !== bar;
}

var actionTypes = {
  RESET_STATE: 'RESET_STATE',
  LOADING: 'LOADING',
  CACHE_HIT: 'CACHE_HIT',
  REQUEST_RESULT: 'REQUEST_RESULT'
};

function reducer(state, action) {
  switch (action.type) {
    case actionTypes.RESET_STATE:
      return action.initialState;

    case actionTypes.LOADING:
      // if the previous action resulted in an error - refetch should clear any errors
      if (state.error) {
        return _objectSpread2(_objectSpread2({}, action.initialState), {}, {
          data: state.data,
          loading: true
        });
      }

      if (state.loading) {
        return state; // saves a render cycle as state is the same
      }

      return _objectSpread2(_objectSpread2({}, state), {}, {
        loading: true
      });

    case actionTypes.CACHE_HIT:
      if (state.cacheHit && !action.resetState) {
        // we can be sure this is the same cacheKey hit
        // because we dispatch RESET_STATE if it changes
        return state;
      }

      return _objectSpread2(_objectSpread2({}, action.result), {}, {
        cacheHit: true,
        loading: false
      });

    case actionTypes.REQUEST_RESULT:
      return _objectSpread2(_objectSpread2({}, action.result), {}, {
        data: state.data && action.result.data && action.updateData ? action.updateData(state.data, action.result.data) : action.result.data,
        cacheHit: false,
        loading: false
      });

    default:
      return state;
  }
}

function useDeepCompareCallback(callback, deps) {
  var ref = React__default['default'].useRef();

  if (!dequal(deps, ref.current)) {
    ref.current = deps;
  }

  return React__default['default'].useCallback(callback, ref.current);
}
/*
  options include:

  opts.variables: Object
  opts.operationName: String
  opts.fetchOptionsOverrides: Object
  opts.skipCache: Boolean
*/


function useClientRequest(query, initialOpts) {
  if (initialOpts === void 0) {
    initialOpts = {};
  }

  if (typeof query !== 'string') {
    throw new Error('Your query must be a string. If you are using the `gql` template literal from graphql-tag, remove it from your query.');
  }

  var contextClient = React__default['default'].useContext(ClientContext);
  var client = initialOpts.client || contextClient;
  var isMounted = React__default['default'].useRef(true);
  var activeCacheKey = React__default['default'].useRef(null);
  var operation = {
    query: query,
    variables: initialOpts.variables,
    operationName: initialOpts.operationName,
    persisted: initialOpts.persisted
  };

  if (initialOpts.persisted || client.useGETForQueries && !initialOpts.isMutation) {
    initialOpts.fetchOptionsOverrides = _objectSpread2(_objectSpread2({}, initialOpts.fetchOptionsOverrides), {}, {
      method: 'GET'
    });
  }

  var cacheKey = client.getCacheKey(operation, initialOpts);
  var isDeferred = initialOpts.isMutation || initialOpts.isManual;
  var initialCacheHit = initialOpts.skipCache || !client.cache ? null : client.cache.get(cacheKey);

  var initialState = _objectSpread2(_objectSpread2({}, initialCacheHit), {}, {
    cacheHit: !!initialCacheHit,
    loading: isDeferred ? false : !initialCacheHit
  });

  var _React$useReducer = React__default['default'].useReducer(reducer, initialState),
      state = _React$useReducer[0],
      dispatch = _React$useReducer[1]; // NOTE: state from useReducer is only initialState on the first render
  // in subsequent renders the operation could have changed
  // if so the state would be invalid, this effect ensures we reset it back


  var stringifiedCacheKey = JSON.stringify(cacheKey);
  React__default['default'].useEffect(function () {
    if (!initialOpts.updateData) {
      // if using updateData we can assume that the consumer cares about the previous data
      dispatch({
        type: actionTypes.RESET_STATE,
        initialState: initialState
      });
    }
  }, [stringifiedCacheKey]); // eslint-disable-line react-hooks/exhaustive-deps

  React__default['default'].useEffect(function () {
    isMounted.current = true;
    return function () {
      isMounted.current = false;
    };
  }, []); // arguments to fetchData override the useClientRequest arguments

  var fetchData = useDeepCompareCallback(function (newOpts) {
    var revisedOpts = _objectSpread2(_objectSpread2({}, initialOpts), newOpts);

    var revisedOperation = _objectSpread2(_objectSpread2({}, operation), {}, {
      variables: revisedOpts.variables,
      operationName: revisedOpts.operationName
    });

    if (!isMounted.current) {
      return Promise.resolve({
        error: {
          fetchError: new Error('fetchData should not be called after hook unmounted')
        },
        loading: false,
        cacheHit: false
      });
    }

    var revisedCacheKey = client.getCacheKey(revisedOperation, revisedOpts); // NOTE: There is a possibility of a race condition whereby
    // the second query could finish before the first one, dispatching an old result
    // see https://github.com/nearform/graphql-hooks/issues/150

    activeCacheKey.current = revisedCacheKey;
    var cacheHit = revisedOpts.skipCache ? null : client.getCache(revisedCacheKey);

    if (cacheHit) {
      dispatch({
        type: actionTypes.CACHE_HIT,
        result: cacheHit,
        resetState: stringifiedCacheKey !== JSON.stringify(state.cacheKey)
      });
      return Promise.resolve(cacheHit);
    }

    dispatch({
      type: actionTypes.LOADING,
      initialState: initialState
    });
    return client.request(revisedOperation, revisedOpts).then(function (result) {
      if (revisedOpts.updateData && typeof revisedOpts.updateData !== 'function') {
        throw new Error('options.updateData must be a function');
      }

      var actionResult = _objectSpread2({}, result);

      if (revisedOpts.useCache) {
        actionResult.useCache = true;
        actionResult.cacheKey = revisedCacheKey;

        if (client.ssrMode) {
          var cacheValue = {
            error: actionResult.error,
            data: revisedOpts.updateData ? revisedOpts.updateData(state.data, actionResult.data) : actionResult.data
          };
          client.saveCache(revisedCacheKey, cacheValue);
        }
      }

      if (isMounted.current && revisedCacheKey === activeCacheKey.current) {
        dispatch({
          type: actionTypes.REQUEST_RESULT,
          updateData: revisedOpts.updateData,
          result: actionResult
        });
      }

      if (initialOpts.isMutation) {
        client.mutationsEmitter.emit(query, _objectSpread2(_objectSpread2({}, revisedOperation), {}, {
          mutation: query,
          result: actionResult
        }));
      }

      return result;
    });
  }, [client, initialOpts, operation]); // We perform caching after reducer update
  // to include the outcome of updateData.
  // The cache is already saved if in ssrMode.

  React__default['default'].useEffect(function () {
    if (state.useCache && !client.ssrMode) {
      client.saveCache(state.cacheKey, state);
    }
  }, [client, state]);

  var reset = function reset(desiredState) {
    if (desiredState === void 0) {
      desiredState = {};
    }

    return dispatch({
      type: actionTypes.RESET_STATE,
      initialState: _objectSpread2(_objectSpread2({}, initialState), desiredState)
    });
  };

  return [fetchData, state, reset];
}

/**
 * Checks values of refetchAfterMutations public option and maps them to an object
 * @typedef {import('../index').RefetchAferMutationsData} RefetchAferMutationsData
 *
 * @param {RefetchAferMutationsData} refetchAfterMutations
 * @returns {object}
 */
function createRefetchMutationsMap(refetchAfterMutations) {
  var mutations = Array.isArray(refetchAfterMutations) ? refetchAfterMutations : [refetchAfterMutations];
  var result = {};
  mutations.forEach(function (mutationInfo) {
    if (mutationInfo == null) return;
    var paramType = typeof mutationInfo;

    if (paramType === 'string') {
      result[mutationInfo] = {};
    } else if (paramType === 'object') {
      var filter = mutationInfo.filter,
          mutation = mutationInfo.mutation;
      result[mutation] = {
        filter: filter
      };
    }
  });
  return result;
}

var defaultOpts = {
  useCache: true,
  skip: false,
  throwErrors: false
};

function useQuery(query, opts) {
  if (opts === void 0) {
    opts = {};
  }

  var allOpts = _objectSpread2(_objectSpread2({}, defaultOpts), opts);

  var contextClient = React__default['default'].useContext(ClientContext);
  var client = opts.client || contextClient;

  var _React$useState = React__default['default'].useState(false),
      calledDuringSSR = _React$useState[0],
      setCalledDuringSSR = _React$useState[1];

  var _useClientRequest = useClientRequest(query, allOpts),
      queryReq = _useClientRequest[0],
      state = _useClientRequest[1];

  if (client.ssrMode && opts.ssr !== false && !calledDuringSSR && !opts.skipCache && !opts.skip) {
    // result may already be in the cache from previous SSR iterations
    if (!state.data && !state.error) {
      var p = queryReq();
      client.ssrPromises.push(p);
    }

    setCalledDuringSSR(true);
  }

  var stringifiedAllOpts = JSON.stringify(allOpts);
  React__default['default'].useEffect(function () {
    if (allOpts.skip) {
      return;
    }

    queryReq();
  }, [query, stringifiedAllOpts]); // eslint-disable-line react-hooks/exhaustive-deps

  React__default['default'].useEffect(function () {
    if (state.error && allOpts.throwErrors) {
      throw state.error;
    }
  }, [state.error, allOpts.throwErrors]);
  var refetch = React__default['default'].useCallback(function (options) {
    if (options === void 0) {
      options = {};
    }

    return queryReq(_objectSpread2({
      skipCache: true,
      // don't call the updateData that has been passed into useQuery here
      // reset to the default behaviour of returning the raw query result
      // this can be overridden in refetch options
      updateData: function updateData(_, data) {
        return data;
      }
    }, options));
  }, [queryReq]);
  React__default['default'].useEffect(function subscribeToMutationsAndRefetch() {
    var mutationsMap = createRefetchMutationsMap(opts.refetchAfterMutations);
    var mutations = Object.keys(mutationsMap);

    var conditionalRefetch = function conditionalRefetch(_ref) {
      var mutation = _ref.mutation,
          variables = _ref.variables;
      var filter = mutationsMap[mutation].filter;

      if (!filter || variables && filter(variables)) {
        refetch();
      }
    };

    mutations.forEach(function (mutation) {
      // this event is emitted from useClientRequest
      client.mutationsEmitter.on(mutation, conditionalRefetch);
    });
    return function () {
      mutations.forEach(function (mutation) {
        client.mutationsEmitter.removeListener(mutation, conditionalRefetch);
      });
    };
  }, [opts.refetchAfterMutations, refetch, client.mutationsEmitter]);
  return _objectSpread2(_objectSpread2({}, state), {}, {
    refetch: refetch
  });
}

function useSubscription(options, callback) {
  var callbackRef = React.useRef(callback);
  callbackRef.current = callback;
  var contextClient = React.useContext(ClientContext);
  var client = options.client || contextClient;
  var request = {
    query: options.query,
    variables: options.variables
  };
  React.useEffect(function () {
    var observable = client.createSubscription(request);
    var subscription = observable.subscribe({
      next: function next(result) {
        callbackRef.current(result);
      },
      error: function error(errors) {
        callbackRef.current({
          errors: errors
        });
      },
      complete: function complete() {
        subscription.unsubscribe();
      }
    });
    return function () {
      subscription.unsubscribe();
    };
  }, []); // eslint-disable-line
  // the effect should be run when component is mounted and unmounted
}

var useManualQuery = function useManualQuery(query, options) {
  return useClientRequest(query, _objectSpread2({
    useCache: true,
    isManual: true
  }, options));
};

var useMutation = function useMutation(query, options) {
  return useClientRequest(query, _objectSpread2({
    isMutation: true
  }, options));
};

exports.ClientContext = ClientContext;
exports.GraphQLClient = GraphQLClient;
exports.LocalGraphQLClient = LocalGraphQLClient;
exports.LocalGraphQLError = LocalGraphQLError;
exports.useClientRequest = useClientRequest;
exports.useManualQuery = useManualQuery;
exports.useMutation = useMutation;
exports.useQuery = useQuery;
exports.useSubscription = useSubscription;

Object.defineProperty(exports, '__esModule', { value: true });

})));
